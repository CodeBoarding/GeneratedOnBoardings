```mermaid
graph LR
    Session_Manager["Session Manager"]
    SQL_Parser["SQL Parser"]
    Schema_Manager["Schema Manager"]
    Query_Planner_Optimizer["Query Planner/Optimizer"]
    Execution_Engine["Execution Engine"]
    Storage_Client["Storage Client"]
    Session_Manager -- "Submits SQL string for parsing." --> SQL_Parser
    SQL_Parser -- "Provides AST for plan generation." --> Query_Planner_Optimizer
    Query_Planner_Optimizer -- "Requests schema and statistics for cost estimation." --> Schema_Manager
    Query_Planner_Optimizer -- "Dispatches the optimized physical plan for execution." --> Execution_Engine
    Execution_Engine -- "Sends key-value requests to access physical data." --> Storage_Client
    Execution_Engine -- "Streams final query results back to the client." --> Session_Manager
```

[![CodeBoarding](https://img.shields.io/badge/Generated%20by-CodeBoarding-9cf?style=flat-square)](https://github.com/CodeBoarding/CodeBoarding)[![Demo](https://img.shields.io/badge/Try%20our-Demo-blue?style=flat-square)](https://www.codeboarding.org/demo)[![Contact](https://img.shields.io/badge/Contact%20us%20-%20contact@codeboarding.org-lightgrey?style=flat-square)](mailto:contact@codeboarding.org)

## Details

One paragraph explaining the functionality which is represented by this graph. What the main flow is and what is its purpose.

### Session Manager
Manages client connections, transactional states, and user-specific context. It serves as the entry point for all queries, receiving the raw SQL string from the client and forwarding it to the parser. It is also the final exit point, streaming results back to the client.


**Related Classes/Methods**:

- `session.session`
- `server.server`


### SQL Parser
Transforms the raw SQL query string into an Abstract Syntax Tree (AST). This component is responsible for syntactic and semantic validation, ensuring the query conforms to the supported SQL dialect. The resulting AST is a structured, hierarchical representation of the query's logic.


**Related Classes/Methods**:

- `parser.parser`


### Schema Manager
Provides access to the database's metadata, including table and index definitions, column types, and statistical information about data distribution (e.g., histograms, cardinality). This information is critical for cost-based optimization.


**Related Classes/Methods**:

- `infoschema.infoschema`


### Query Planner/Optimizer
The core of query optimization. It receives the AST from the parser and generates an efficient physical execution plan. This process involves two main phases: logical optimization (e.g., predicate pushdown, join reordering) and physical optimization (e.g., choosing specific join algorithms, selecting indexes).


**Related Classes/Methods**:

- `planner.core.planner`


### Execution Engine
Executes the physical plan generated by the optimizer. It interprets the plan's operators (e.g., TableScan, Join, Aggregate) and orchestrates data retrieval and processing. For distributed queries, it schedules and coordinates tasks across multiple compute nodes.


**Related Classes/Methods**:

- `executor.executor`


### Storage Client
An abstraction layer that communicates with the underlying distributed key-value storage layer (e.g., TiKV). It translates the Execution Engine's requests for data into low-level key-value operations (e.g., Get, Scan, Put).


**Related Classes/Methods**:

- `store.tikv.client`
- `kv.kv`




### [FAQ](https://github.com/CodeBoarding/GeneratedOnBoardings/tree/main?tab=readme-ov-file#faq)